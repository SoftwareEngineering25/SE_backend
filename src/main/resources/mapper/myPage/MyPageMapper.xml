<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.dr.mapper.myPage.MyPageMapper">

    <!-- 자기 자신 정보 확인(내정보) (MySQL 호환) -->
    <select id="getUserInfo" parameterType="Long" resultType="UserInfoDTO">
        SELECT
        U.USER_NICKNAME AS USER_NICKNAME,
        U.USER_EMAIL AS USER_EMAIL,
        U.USER_PHONE AS USER_PHONE,
        U.PROFILE_PIC AS PROFILE_PIC,
        COALESCE(S.ENVIRONMENT_SCORE, 0) AS ENVIRONMENT_SCORE,
        COALESCE(R.ENVIRONMENT_RANK, 0) AS ENVIRONMENT_RANK,
        COALESCE(P.TOTAL_POINTS, 0) AS TOTAL_POINTS,
        PH.PHOTO_LOCAL AS PHOTO
        FROM
        DR_USER U
        LEFT JOIN
        (SELECT
        USER_NUMBER,
        SUM(SCORE_GET) AS ENVIRONMENT_SCORE
        FROM
        DR_SCORE
        GROUP BY USER_NUMBER) S ON U.USER_NUMBER = S.USER_NUMBER
        LEFT JOIN
        (SELECT
        USER_NUMBER,
        DENSE_RANK() OVER (ORDER BY SUM(SCORE_GET) DESC) AS ENVIRONMENT_RANK
        FROM
        DR_SCORE
        GROUP BY USER_NUMBER) R ON U.USER_NUMBER = R.USER_NUMBER
        LEFT JOIN
        (SELECT
        USER_NUMBER,
        SUM(POINT_CHANGE) AS TOTAL_POINTS
        FROM
        DR_POINT
        GROUP BY USER_NUMBER) P ON U.USER_NUMBER = P.USER_NUMBER
        LEFT JOIN
        (SELECT
        USER_NUMBER,
        PHOTO_LOCAL
        FROM
        DR_PHOTO
        WHERE USER_NUMBER IS NOT NULL
        AND PHOTO_LOCAL IS NOT NULL
        ) PH ON U.USER_NUMBER = PH.USER_NUMBER
        WHERE
        U.USER_NUMBER = #{userNumber}
    </select>

    <!-- 닉네임 업데이트 (MySQL 호환) -->
    <update id="updateNickname">
        UPDATE DR_USER
        SET USER_NICKNAME = #{nickname}
        WHERE USER_NUMBER = #{userNumber}
    </update>

    <!-- 프로필 이미지 경로 업데이트 (MySQL 호환) -->
    <!-- 참고: DR_PHOTO에 사용자 프로필 사진 레코드가 없을 경우 INSERT 필요 -->
    <update id="updateProfileImage">
        UPDATE DR_PHOTO
        SET PHOTO_LOCAL = #{photoLocal}
        WHERE USER_NUMBER = #{userNumber}
        <!-- AND 특정 조건 (예: 프로필 사진임을 나타내는 컬럼) -->
        <!-- UPDATE 대상이 없을 경우 INSERT 로직 추가 고려 -->
    </update>

    <!-- 닉네임 중복 확인 (MySQL 호환) -->
    <select id="checkNickname" parameterType="string" resultType="int">
        SELECT COUNT(*)
        FROM DR_USER
        WHERE USER_NICKNAME = #{userNickname}
    </select>

    <!-- 회원 탈퇴 (MySQL 호환) -->
    <delete id="deleteUser" parameterType="Long">
        DELETE FROM DR_USER
        WHERE USER_NUMBER = #{userNumber}
    </delete>

    <!-- 내정보 포인트 내역 확인 (MySQL 8.0+ 호환) -->
    <select id="pointHistory" parameterType="Long" resultType="PointDetailDTO">
        SELECT
            DP.POINT_NUMBER,
            DP.POINT_NOTE,
            DP.POINT_CHANGE AS pointGet, -- POINT_CHANGE 컬럼 사용 (스키마 확인)
            DATE_FORMAT(DP.POINT_DATE, '%Y-%m-%d %H:%i:%s') AS pointDate, -- TO_CHAR -> DATE_FORMAT
            SUM(DP.POINT_CHANGE) OVER (ORDER BY DP.POINT_DATE ASC, DP.POINT_NUMBER ASC) AS totalPoints -- 누적 합계 (Window Function)
        FROM DR_POINT DP
        WHERE DP.USER_NUMBER = #{userNumber}
        ORDER BY DP.POINT_DATE DESC, DP.POINT_NUMBER DESC
    </select>

    <!-- 내정보 내가 쓴 레시피 목록 (MySQL 8.0+ 호환) -->
    <select id="getUserRecipe" parameterType="Long" resultType="UserRecipeDTO">
        SELECT
            R.RECIPE_NUMBER,
            P.RECIPE_PHOTO, -- 컬럼명 확인 (PHOTO_ORIGINAL or PHOTO_LOCAL)
            R.RECIPE_TITLE,
            DATE_FORMAT(R.RECIPE_WRITE_DATE, '%Y-%m-%d') AS RECIPE_WRITE_DATE, -- TO_CHAR -> DATE_FORMAT
            (SELECT COUNT(*) FROM DR_GOOD G WHERE G.RECIPE_NUMBER = R.RECIPE_NUMBER) AS GOOD_COUNT,
            R.RECIPE_TYPE
        FROM DR_RECIPE R
                 LEFT JOIN (
            SELECT
                PHOTO_ORIGINAL AS RECIPE_PHOTO, -- 원본 파일명 사용? PHOTO_LOCAL(경로)이 더 적합할 수 있음
                RECIPE_NUMBER,
                ROW_NUMBER() OVER (PARTITION BY RECIPE_NUMBER ORDER BY PHOTO_NUMBER ASC) AS RN -- MySQL 8.0+
            FROM DR_PHOTO
            WHERE RECIPE_NUMBER IS NOT NULL
        ) P ON R.RECIPE_NUMBER = P.RECIPE_NUMBER AND P.RN = 1
        WHERE R.USER_NUMBER = #{userNumber}
        ORDER BY R.RECIPE_WRITE_DATE DESC
    </select>

    <!-- 내정보 내가 쓴 게시글 목록 (MySQL 8.0+ 호환) -->
    <select id="getUserPost" parameterType="Long" resultType="UserPostDTO">
        SELECT
            ROW_NUMBER() OVER (ORDER BY B.BOARD_WRITE_DATE DESC) AS MY_POST_SEQ, -- MySQL 8.0+
                B.BOARD_TITLE AS MY_POST_TITLE,
            B.BOARD_TYPE AS MY_POST_TYPE,
            COALESCE(GOOD_COUNT.LIKES, 0) AS MY_POSTGOOD_COUNT, -- NVL -> COALESCE
            DATE_FORMAT(B.BOARD_WRITE_DATE, '%Y-%m-%d') AS MY_POST_WRITE_DATE, -- TO_CHAR -> DATE_FORMAT
            B.BOARD_NUMBER AS BOARD_NUMBER,
            B.USER_NUMBER AS USER_NUMBER
        FROM DR_BOARD B
                 LEFT JOIN (
            SELECT
                BOARD_NUMBER, COUNT(*) AS LIKES
            FROM DR_GOOD
            GROUP BY BOARD_NUMBER
        ) GOOD_COUNT ON B.BOARD_NUMBER = GOOD_COUNT.BOARD_NUMBER
        WHERE B.USER_NUMBER = #{userNumber}
        ORDER BY B.BOARD_WRITE_DATE DESC
    </select>

    <!-- 내정보 찜 목록 (MySQL 8.0+ 호환) -->
    <select id="getUserSteam" parameterType="Long" resultType="UserSteamDTO">
        SELECT
            R.RECIPE_NUMBER,
            R.RECIPE_TITLE,
            U.USER_NICKNAME,
            P.PHOTO_ORIGINAL, -- 컬럼명 확인 (PHOTO_ORIGINAL or PHOTO_LOCAL)
            R.RECIPE_TYPE
        FROM
            DR_STEAM S
                JOIN
            DR_RECIPE R ON S.RECIPE_NUMBER = R.RECIPE_NUMBER
                JOIN
            DR_USER U ON R.USER_NUMBER = U.USER_NUMBER
                LEFT JOIN (
                SELECT
                    PHOTO_ORIGINAL, -- 원본 파일명 사용? PHOTO_LOCAL(경로)이 더 적합할 수 있음
                    RECIPE_NUMBER,
                    ROW_NUMBER() OVER (PARTITION BY RECIPE_NUMBER ORDER BY PHOTO_NUMBER ASC) AS RN -- MySQL 8.0+
                FROM
                    DR_PHOTO
                WHERE RECIPE_NUMBER IS NOT NULL
            ) P ON R.RECIPE_NUMBER = P.RECIPE_NUMBER AND P.RN = 1
        WHERE
            S.USER_NUMBER = #{userNumber}
        ORDER BY
            S.STEAM_DATE DESC
    </select>

    <!-- 내정보 찜 목록 삭제 (MySQL 호환) -->
    <delete id="deleteUserSteam" parameterType="UserSteamDTO">
        DELETE FROM DR_STEAM
        WHERE USER_NUMBER = #{userNumber}
          AND RECIPE_NUMBER = #{recipeNumber}
    </delete>

    <!-- 내정보 신고 내역 (MySQL 호환) -->
    <!-- 참고: WHERE 조건이 신고 '당한' 사용자를 찾는 것으로 보임. 신고 '한' 내역을 보려면 WHERE S.USER_NUMBER = #{userNumber} 사용 -->
    <select id="getSirenList" parameterType="Long" resultType="SirenListDTO">
        SELECT
            S.SIREN_NUMBER AS sirenNumber,
            COALESCE(B.BOARD_TITLE, R.RECIPE_TITLE, RP.REPLY_TEXT) AS titleAndContent,
            S.SIREN_TYPE AS sirenType,
            S.SIREN_REASON AS sirenReason,
            DATE_FORMAT(S.SIREN_DATE, '%Y-%m-%d') AS sirenDate,
            COALESCE(S.BOARD_NUMBER, RP.BOARD_NUMBER) AS boardNumber,
            S.RECIPE_NUMBER AS recipeNumber,
            S.REPLY_NUMBER AS replyNumber
        FROM DR_SIREN S
                 LEFT JOIN DR_BOARD B ON S.BOARD_NUMBER = B.BOARD_NUMBER
                 LEFT JOIN DR_RECIPE R ON S.RECIPE_NUMBER = R.RECIPE_NUMBER
                 LEFT JOIN DR_REPLY RP ON S.REPLY_NUMBER = RP.REPLY_NUMBER

                 LEFT JOIN DR_USER U_TARGET ON (B.USER_NUMBER = U_TARGET.USER_NUMBER OR R.USER_NUMBER = U_TARGET.USER_NUMBER OR RP.USER_NUMBER = U_TARGET.USER_NUMBER)
        WHERE U_TARGET.USER_NUMBER = #{userNumber}
        ORDER BY S.SIREN_DATE DESC
    </select>

    <!-- 1. 오늘의 출석 여부 확인 (MySQL 호환) -->
    <select id="todayCheck" parameterType="long" resultType="int">
        SELECT COUNT(*)
        FROM DR_DAILY
        WHERE USER_NUMBER = #{userNumber}
          AND DATE(DAILY_DATE) = CURDATE() -- TRUNC -> DATE, SYSDATE -> CURDATE
    </select>

    <!-- 2. 출석 기록 삽입 (MySQL 호환: AUTO_INCREMENT 사용) -->
    <insert id="insertCheck" parameterType="CheckDTO" useGeneratedKeys="true" keyProperty="dailyNumber">
        <!-- Oracle 시퀀스 대신 AUTO_INCREMENT 사용 -->
        INSERT INTO DR_DAILY (USER_NUMBER, DAILY_DATE)
        VALUES (#{userNumber}, NOW()) -- SYSDATE -> NOW()
    </insert>

    <!-- 3. 개근 여부 확인 (시연 테스트 : 14일 전부터 오늘까지 14일 출석 시 개근 인정) (MySQL 호환) -->
    <select id="monthFullCheck" parameterType="long" resultType="int">
        SELECT
            CASE
                WHEN COUNT(DISTINCT DATE(DAILY_DATE)) >= 14 THEN 1  -- 개근 (14일 이상 출석)
                ELSE 0  -- 개근 아님
                END AS full_attendance
        FROM
            DR_DAILY
        WHERE
            USER_NUMBER = #{userNumber}
          AND DATE(DAILY_DATE) BETWEEN CURDATE() - INTERVAL 13 DAY AND CURDATE() -- TRUNC, SYSDATE 변경
        -- GROUP BY USER_NUMBER -- 결과가 항상 1행이므로 불필요
    </select>

    <!-- 4. 출석체크 시 포인트 적립 (MySQL 호환: AUTO_INCREMENT 사용) -->
    <insert id="insertPointRecord" parameterType="PointCheckDTO" useGeneratedKeys="true" keyProperty="pointNumber">
        <!-- Oracle 시퀀스 대신 AUTO_INCREMENT 사용 -->
        <!-- 컬럼명 확인: POINT_GET -> POINT_CHANGE? -->
        INSERT INTO DR_POINT (POINT_CHANGE, POINT_NOTE, USER_NUMBER, POINT_DATE)
        VALUES (#{pointGet}, #{pointNote}, #{userNumber}, NOW()) -- SYSDATE -> NOW()
    </insert>

    <!-- 5. 출석 체크 날짜 리스트 조회 (MySQL 호환) -->
    <select id="getAttendanceDates" parameterType="long" resultType="CheckDTO">
        SELECT DATE_FORMAT(DAILY_DATE, '%Y-%m-%d') AS dailyDate -- TO_CHAR -> DATE_FORMAT
        FROM DR_DAILY
        WHERE USER_NUMBER = #{userNumber}
        ORDER BY DAILY_DATE DESC
    </select>
</mapper>